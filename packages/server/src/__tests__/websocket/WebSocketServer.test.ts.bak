import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
import { WebSocketServer } from '../../websocket/WebSocketServer.js';
import { createServer, Server as HTTPServer } from 'http';
import { WebSocket } from 'ws';
import jwt from 'jsonwebtoken';

type WebSocketMessage = {
  type: string;
  clientId?: string;
  serverTime?: number;
  error?: string;
  message?: string;
  status?: string;
  transferId?: string;
  data?: unknown;
};

// Helper to create promise-based WebSocket tests
function createWebSocketTest(testFn: (ws: WebSocket, resolve: () => void, reject: (err: Error) => void) => void): () => Promise<void> {
  return () => new Promise<void>((resolve, reject) => {
    const ws = new WebSocket(`ws://localhost:${port}`);
    ws.on('error', reject);
    testFn(ws, resolve, reject);
  });
}

// Mock dependencies
vi.mock('../../utils/logger.js', () => ({
  logger: {
    info: vi.fn(),
    warn: vi.fn(),
    error: vi.fn(),
    debug: vi.fn(),
  }
}));

// Mock nanoid
vi.mock('nanoid', () => ({
  nanoid: vi.fn(() => 'test-client-id')
}));

// Mock jwt
vi.mock('jsonwebtoken', () => ({
  default: {
    verify: vi.fn(),
    sign: vi.fn()
  }
}));

describe('WebSocketServer', () => {
  let wsServer: WebSocketServer;
  let httpServer: HTTPServer;
  let port: number;
  let jwtSecret: string;

  beforeEach(async () => {
    port = 0; // Let the system assign a free port
    jwtSecret = 'test-secret';
    httpServer = createServer();
    httpServer.setMaxListeners(50); // Increase to avoid warnings
    
    await new Promise<void>((resolve) => {
      httpServer.listen(port, () => {
        const address = httpServer.address();
        if (address && typeof address !== 'string') {
          port = address.port;
        }
        try {
          wsServer = new WebSocketServer(httpServer, jwtSecret);
          resolve();
        } catch (error) {
          console.error('Failed to create WebSocketServer:', error);
          resolve(); // Still resolve to continue tests but wsServer will be undefined
        }
      });
    });
  });

  afterEach(async () => {
    if (wsServer) {
      wsServer.close();
    }
    await new Promise<void>((resolve) => {
      httpServer.close(() => resolve());
    });
  });

  describe('constructor', () => {
    it('should create WebSocketServer with HTTP server and JWT secret', () => {
      expect(wsServer).toBeDefined();
      expect(wsServer).toBeInstanceOf(WebSocketServer);
    });

    it('should use provided JWT secret', () => {
      const customSecret = 'custom-secret';
      const customWsServer = new WebSocketServer(httpServer, customSecret);
      
      expect(customWsServer).toBeDefined();
      customWsServer.close();
    });

    it('should use default JWT secret when not provided', () => {
      const defaultWsServer = new WebSocketServer(httpServer);
      
      expect(defaultWsServer).toBeDefined();
      defaultWsServer.close();
    });
  });

  describe('client connections', () => {
    it('should handle client connection', () => {
      return new Promise<void>((resolve, reject) => {
        const ws = new WebSocket(`ws://localhost:${port}`);

        ws.on('message', (data) => {
          const message = JSON.parse(data.toString()) as WebSocketMessage;
          if (message.type === 'connected') {
            expect(message.clientId).toBe('test-client-id');
            expect(message.serverTime).toBeTypeOf('number');
            ws.close();
            resolve();
          }
        });

        ws.on('error', reject);
      });
    });

    it('should handle client disconnection', () => {
      return new Promise<void>((resolve, reject) => {
        const ws = new WebSocket(`ws://localhost:${port}`);

        ws.on('open', () => {
          expect(wsServer.getConnectionCount()).toBe(1);
          ws.close();
        });

        ws.on('close', () => {
          // Give some time for the server to process the disconnect
          setTimeout(() => {
            expect(wsServer.getConnectionCount()).toBe(0);
            resolve();
          }, 10);
        });

        ws.on('error', reject);
      });
    });

    it('should handle invalid JSON messages', () => {
      return new Promise<void>((resolve, reject) => {
        const ws = new WebSocket(`ws://localhost:${port}`);

        ws.on('message', (data) => {
          const message = JSON.parse(data.toString()) as WebSocketMessage;
          if (message.type === 'connected') {
            ws.send('invalid json {');
          } else if (message.type === 'error' && message.error === 'Invalid message format') {
            ws.close();
            resolve();
          }
        });

        ws.on('error', reject);
      });
    });
  });

  describe('authentication', () => {
    it('should authenticate client with valid JWT token', (done) => {
      const mockDecodedToken = {
        sessionId: 'test-session',
        userId: 'test-user',
        exp: Math.floor(Date.now() / 1000) + 3600
      };

      vi.mocked(jwt.verify).mockReturnValue(mockDecodedToken as jwt.JwtPayload);

      const ws = new WebSocket(`ws://localhost:${port}`);

      ws.on('message', (data) => {
        const message = JSON.parse(data.toString()) as WebSocketMessage;
        if (message.type === 'connected') {
          ws.send(JSON.stringify({
            type: 'auth',
            token: 'valid-jwt-token'
          }));
        } else if (message.type === 'auth:success') {
          expect(message.sessionId).toBe('test-session');
          expect(message.userId).toBe('test-user');
          expect(wsServer.getAuthenticatedCount()).toBe(1);
          ws.close();
          done();
        }
      });

      ws.on('error', done);
    });

    it('should reject client with invalid JWT token', (done) => {
      vi.mocked(jwt.verify).mockImplementation(() => {
        throw new Error('Invalid token');
      });

      const ws = new WebSocket(`ws://localhost:${port}`);

      ws.on('message', (data) => {
        const message = JSON.parse(data.toString()) as WebSocketMessage;
        if (message.type === 'connected') {
          ws.send(JSON.stringify({
            type: 'auth',
            token: 'invalid-jwt-token'
          }));
        } else if (message.type === 'auth:failed') {
          expect(message.error).toBe('Invalid credentials');
          expect(wsServer.getAuthenticatedCount()).toBe(0);
          ws.close();
          done();
        }
      });

      ws.on('error', done);
    });

    it('should authenticate client with valid session ID using validator', (done) => {
      const validator = vi.fn().mockResolvedValue(true);
      wsServer.setSessionValidator(validator);

      const ws = new WebSocket(`ws://localhost:${port}`);

      ws.on('message', (data) => {
        const message = JSON.parse(data.toString()) as WebSocketMessage;
        if (message.type === 'connected') {
          ws.send(JSON.stringify({
            type: 'auth',
            sessionId: 'valid-session-id'
          }));
        } else if (message.type === 'auth:success') {
          expect(message.sessionId).toBe('valid-session-id');
          expect(validator).toHaveBeenCalledWith('valid-session-id');
          expect(wsServer.getAuthenticatedCount()).toBe(1);
          ws.close();
          done();
        }
      });

      ws.on('error', done);
    });

    it('should reject client with invalid session ID using validator', (done) => {
      const validator = vi.fn().mockResolvedValue(false);
      wsServer.setSessionValidator(validator);

      const ws = new WebSocket(`ws://localhost:${port}`);

      ws.on('message', (data) => {
        const message = JSON.parse(data.toString()) as WebSocketMessage;
        if (message.type === 'connected') {
          ws.send(JSON.stringify({
            type: 'auth',
            sessionId: 'invalid-session-id'
          }));
        } else if (message.type === 'auth:failed') {
          expect(message.error).toBe('Invalid credentials');
          expect(validator).toHaveBeenCalledWith('invalid-session-id');
          expect(wsServer.getAuthenticatedCount()).toBe(0);
          ws.close();
          done();
        }
      });

      ws.on('error', done);
    });

    it('should accept any session ID when no validator is set', (done) => {
      const ws = new WebSocket(`ws://localhost:${port}`);

      ws.on('message', (data) => {
        const message = JSON.parse(data.toString()) as WebSocketMessage;
        if (message.type === 'connected') {
          ws.send(JSON.stringify({
            type: 'auth',
            sessionId: 'any-session-id'
          }));
        } else if (message.type === 'auth:success') {
          expect(message.sessionId).toBe('any-session-id');
          expect(wsServer.getAuthenticatedCount()).toBe(1);
          ws.close();
          done();
        }
      });

      ws.on('error', done);
    });
  });

  describe('subscriptions', () => {
    let authenticatedWs: WebSocket;

    beforeEach(async () => {
      authenticatedWs = new WebSocket(`ws://localhost:${port}`);
      
      await new Promise<void>((resolve, reject) => {
        authenticatedWs.on('message', (data) => {
          const message = JSON.parse(data.toString()) as WebSocketMessage;
          if (message.type === 'connected') {
            authenticatedWs.send(JSON.stringify({
              type: 'auth',
              sessionId: 'test-session'
            }));
          } else if (message.type === 'auth:success') {
            resolve();
          }
        });

        authenticatedWs.on('error', reject);
      });
    });

    afterEach(() => {
      if (authenticatedWs.readyState === WebSocket.OPEN) {
        authenticatedWs.close();
      }
    });

    it('should allow authenticated client to subscribe to transfer', async () => {
      const transferId = 'test-transfer-123';

      const messagePromise = new Promise<void>((resolve) => {
        authenticatedWs.on('message', (data) => {
          const message = JSON.parse(data.toString()) as WebSocketMessage;
          if (message.type === 'subscribed') {
            expect(message.transferId).toBe(transferId);
            expect(wsServer.getTransferSubscribers(transferId)).toContain('test-client-id');
            resolve();
          }
        });
      });

      authenticatedWs.send(JSON.stringify({
        type: 'subscribe',
        transferId
      }));

      await messagePromise;
    });

    it('should allow authenticated client to unsubscribe from transfer', async () => {
      const transferId = 'test-transfer-123';

      let subscribed = false;

      const messagePromise = new Promise<void>((resolve) => {
        authenticatedWs.on('message', (data) => {
          const message = JSON.parse(data.toString()) as WebSocketMessage;
          if (message.type === 'subscribed' && !subscribed) {
            subscribed = true;
            authenticatedWs.send(JSON.stringify({
              type: 'unsubscribe',
              transferId
            }));
          } else if (message.type === 'unsubscribed') {
            expect(message.transferId).toBe(transferId);
            expect(wsServer.getTransferSubscribers(transferId)).not.toContain('test-client-id');
            resolve();
          }
        });
      });

      authenticatedWs.send(JSON.stringify({
        type: 'subscribe',
        transferId
      }));

      await messagePromise;
    });

    it('should reject subscription from unauthenticated client', (done) => {
      const unauthenticatedWs = new WebSocket(`ws://localhost:${port}`);

      unauthenticatedWs.on('message', (data) => {
        const message = JSON.parse(data.toString()) as WebSocketMessage;
        if (message.type === 'connected') {
          unauthenticatedWs.send(JSON.stringify({
            type: 'subscribe',
            transferId: 'test-transfer'
          }));
        } else if (message.type === 'error') {
          expect(message.error).toBe('Not authenticated');
          unauthenticatedWs.close();
          done();
        }
      });

      unauthenticatedWs.on('error', done);
    });
  });

  describe('broadcasting', () => {
    let authenticatedWs: WebSocket;
    const transferId = 'test-transfer-123';

    beforeEach((done) => {
      authenticatedWs = new WebSocket(`ws://localhost:${port}`);
      let authenticated = false;
      let subscribed = false;

      authenticatedWs.on('message', (data) => {
        const message = JSON.parse(data.toString()) as WebSocketMessage;
        if (message.type === 'connected' && !authenticated) {
          authenticatedWs.send(JSON.stringify({
            type: 'auth',
            sessionId: 'test-session'
          }));
        } else if (message.type === 'auth:success' && !authenticated) {
          authenticated = true;
          authenticatedWs.send(JSON.stringify({
            type: 'subscribe',
            transferId
          }));
        } else if (message.type === 'subscribed' && !subscribed) {
          subscribed = true;
          done();
        }
      });

      authenticatedWs.on('error', done);
    });

    afterEach(() => {
      if (authenticatedWs.readyState === WebSocket.OPEN) {
        authenticatedWs.close();
      }
    });

    it('should broadcast to clients subscribed to specific transfer', (done) => {
      const eventData = { status: 'updated', progress: 50 };

      authenticatedWs.on('message', (data) => {
        const message = JSON.parse(data.toString()) as WebSocketMessage;
        if (message.type === 'event' && message.event === 'transfer:update') {
          expect(message.transferId).toBe(transferId);
          expect(message.data).toEqual(eventData);
          done();
        }
      });

      wsServer.broadcastToTransfer(transferId, 'transfer:update', eventData);
    });

    it('should broadcast to all authenticated clients', (done) => {
      const eventData = { message: 'System maintenance in 10 minutes' };

      authenticatedWs.on('message', (data) => {
        const message = JSON.parse(data.toString()) as WebSocketMessage;
        if (message.type === 'broadcast' && message.event === 'system:announcement') {
          expect(message.data).toEqual(eventData);
          done();
        }
      });

      wsServer.broadcast('system:announcement', eventData);
    });

    it('should send event to specific client', async () => {
      const eventData = { notification: 'Your document has been signed' };
      
      // Create a fresh WebSocket connection to capture the client ID
      const testWs = new WebSocket(`ws://localhost:${port}`);
      let actualClientId: string;

      // Wait for the connected message to get the actual client ID and authenticate
      await new Promise<void>((resolve, reject) => {
        testWs.on('message', (data) => {
          const message = JSON.parse(data.toString()) as WebSocketMessage;
          if (message.type === 'connected') {
            actualClientId = message.clientId;
            testWs.send(JSON.stringify({
              type: 'auth',
              sessionId: 'test-session'
            }));
          } else if (message.type === 'auth:success') {
            resolve();
          }
        });
        testWs.on('error', reject);
      });

      const messagePromise = new Promise<void>((resolve) => {
        testWs.on('message', (data) => {
          const message = JSON.parse(data.toString()) as WebSocketMessage;
          if (message.type === 'event' && message.event === 'document:signed') {
            expect(message.data).toEqual(eventData);
            resolve();
          }
        });
      });

      const success = wsServer.sendToClient(actualClientId!, 'document:signed', eventData);
      expect(success).toBe(true);
      
      await messagePromise;
      testWs.close();
    });

    it('should return false when sending to non-existent client', () => {
      const success = wsServer.sendToClient('non-existent-client', 'test:event', {});
      expect(success).toBe(false);
    });
  });

  describe('statistics and monitoring', () => {
    it('should return connection statistics', () => {
      const stats = wsServer.getConnectionStats();
      
      expect(stats).toEqual({
        total: 0,
        authenticated: 0,
        subscriptions: 0,
        averageUptime: 0
      });
    });

    it('should return correct connection count', () => {
      expect(wsServer.getConnectionCount()).toBe(0);
    });

    it('should return correct authenticated count', () => {
      expect(wsServer.getAuthenticatedCount()).toBe(0);
    });

    it('should return transfer subscribers', () => {
      const subscribers = wsServer.getTransferSubscribers('test-transfer');
      expect(subscribers).toEqual([]);
    });

    it('should calculate statistics correctly with connected clients', (done) => {
      const ws = new WebSocket(`ws://localhost:${port}`);

      ws.on('message', (data) => {
        const message = JSON.parse(data.toString()) as WebSocketMessage;
        if (message.type === 'connected') {
          ws.send(JSON.stringify({
            type: 'auth',
            sessionId: 'test-session'
          }));
        } else if (message.type === 'auth:success') {
          ws.send(JSON.stringify({
            type: 'subscribe',
            transferId: 'test-transfer'
          }));
        } else if (message.type === 'subscribed') {
          const stats = wsServer.getConnectionStats();
          expect(stats.total).toBe(1);
          expect(stats.authenticated).toBe(1);
          expect(stats.subscriptions).toBe(1);
          expect(stats.averageUptime).toBeGreaterThan(0);
          
          expect(wsServer.getConnectionCount()).toBe(1);
          expect(wsServer.getAuthenticatedCount()).toBe(1);
          expect(wsServer.getTransferSubscribers('test-transfer')).toContain('test-client-id');
          
          ws.close();
          done();
        }
      });

      ws.on('error', done);
    });
  });

  describe('message handling edge cases', () => {
    it('should handle unknown message types', (done) => {
      const ws = new WebSocket(`ws://localhost:${port}`);

      ws.on('message', (data) => {
        const message = JSON.parse(data.toString()) as WebSocketMessage;
        if (message.type === 'connected') {
          ws.send(JSON.stringify({
            type: 'unknown-message-type',
            data: 'test'
          }));
        } else if (message.type === 'error') {
          expect(message.error).toBe('Unknown message type');
          ws.close();
          done();
        }
      });

      ws.on('error', done);
    });

    it('should handle authentication errors gracefully', (done) => {
      const validator = vi.fn().mockRejectedValue(new Error('Database error'));
      wsServer.setSessionValidator(validator);

      const ws = new WebSocket(`ws://localhost:${port}`);

      ws.on('message', (data) => {
        const message = JSON.parse(data.toString()) as WebSocketMessage;
        if (message.type === 'connected') {
          ws.send(JSON.stringify({
            type: 'auth',
            sessionId: 'test-session'
          }));
        } else if (message.type === 'error') {
          expect(message.error).toBe('Authentication error');
          ws.close();
          done();
        }
      });

      ws.on('error', done);
    });
  });

  describe('connection cleanup', () => {
    it('should handle WebSocket errors gracefully', (done) => {
      const ws = new WebSocket(`ws://localhost:${port}`);

      ws.on('open', () => {
        // Force a WebSocket error by closing the underlying socket
        const wsAny = ws as WebSocket & { _socket?: { destroy(): void } };
        wsAny._socket?.destroy();
      });

      // Just ensure the server doesn't crash
      setTimeout(() => {
        expect(wsServer.getConnectionCount()).toBe(0);
        done();
      }, 100);
    });

    it('should handle pong messages for keepalive', (done) => {
      const ws = new WebSocket(`ws://localhost:${port}`);

      ws.on('ping', () => {
        ws.pong();
        // Verify that the server processes the pong (updates lastActivity)
        setTimeout(() => {
          const stats = wsServer.getConnectionStats();
          expect(stats.total).toBe(1);
          ws.close();
          done();
        }, 10);
      });

      ws.on('open', () => {
        // Trigger a ping manually to test pong handling
        const wsAny = ws as WebSocket & { ping(): void };
        wsAny.ping();
      });

      ws.on('error', done);
    });
  });

  describe('setSessionValidator', () => {
    it('should set and use session validator', () => {
      const mockValidator = vi.fn().mockResolvedValue(true);
      wsServer.setSessionValidator(mockValidator);

      // Access the private method to test it directly
      const wsServerAny = wsServer as WebSocketServer & { sessionValidationCallback?: typeof mockValidator };
      expect(wsServerAny.sessionValidationCallback).toBe(mockValidator);
    });
  });

  describe('close', () => {
    it('should close the WebSocket server', () => {
      const closeSpy = vi.spyOn(wsServer as WebSocketServer & Record<string, unknown>, 'close') as typeof wsServer.close;
      wsServer.close();
      expect(closeSpy).toHaveBeenCalled();
    });
  });
});